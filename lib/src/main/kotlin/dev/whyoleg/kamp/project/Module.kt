package dev.whyoleg.kamp.project

import dev.whyoleg.kamp.dependency.*

typealias ProjectModule = KampProjectDependency

@PublishedApi
internal data class ModuleResolveResult(val modules: List<ModuleWithPath>, val cls: String)

@PublishedApi
internal data class ModuleWithPath(val name: String, val path: String?)

@PublishedApi
internal fun ModuleResolveResult(ctx: ModuleContext): ModuleResolveResult = ModuleResolveResult(
    ctx.modules(),
    (listOf(
        "import dev.whyoleg.kamp.project.*",
        "",
        "//Autogenerated with kamp, don't change"
    ) + ctx.classes() + "").joinToString("\n")
)

data class ModuleContext
@PublishedApi
internal constructor(
    private val name: String,
    @PublishedApi
    internal val gradleName: String,
    private val path: String?,
    private val ignore: Boolean,
    @PublishedApi
    internal val inner: MutableList<ModuleContext> = mutableListOf()
) {
    inline operator fun String.invoke(path: String? = null, ignore: Boolean = false, block: ModuleContext.() -> Unit = {}) {
        val n = toLowerCase()
        inner += ModuleContext(n, "$gradleName:$n", path, ignore).apply(block)
    }

    internal fun modules(): List<ModuleWithPath> {
        val current = if (name.isBlank()) emptyList() else listOf(ModuleWithPath(gradleName, path))
        val nested = inner.filterNot(ModuleContext::ignore).flatMap(ModuleContext::modules)
        return current + nested
    }

    internal fun classes(): List<String> {
        val n =
            name.takeIf(String::isNotBlank)
                ?.map { it.takeIf(Char::isLetterOrDigit)?.toString() ?: "_" }
                ?.joinToString("")
                ?.let { if (it[0].isDigit()) "_$it" else it }
        return when {
            inner.isNotEmpty() -> listOf("", "object ${n?.capitalize() ?: "Modules"} {") + inner.classes() + "}"
            n != null          -> listOf("val $n = ProjectModule(\"$gradleName\")")
            else               -> error("No modules in root")
        }
    }

    private fun List<ModuleContext>.classes(): List<String> = flatMap(ModuleContext::classes).map { if (it.isBlank()) it else "    $it" }

}

@PublishedApi
internal inline fun resolveModules(block: ModuleContext.() -> Unit): ModuleResolveResult =
    ModuleResolveResult(ModuleContext("", "", null, false).apply(block))
